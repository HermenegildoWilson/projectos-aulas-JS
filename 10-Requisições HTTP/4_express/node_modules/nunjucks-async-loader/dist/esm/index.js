import { readFile, lstat } from 'node:fs/promises';
import path from 'node:path';
import { Loader } from 'nunjucks';
import chokidar, {} from 'chokidar';
export class FileSystemAsyncLoader extends Loader {
    async = true;
    pathsToNames = {};
    searchPaths = [];
    noCache;
    fsWatcher;
    constructor(searchPaths, opts) {
        super();
        const config = opts ?? {};
        if (searchPaths) {
            searchPaths = Array.isArray(searchPaths) ? searchPaths : [searchPaths];
            searchPaths = searchPaths.map(path.normalize);
        }
        else {
            searchPaths = ['.'];
        }
        this.searchPaths = searchPaths;
        this.noCache = !!config.noCache;
        if (config.watch) {
            this.watchDirs(searchPaths).catch(console.error);
        }
    }
    async watchDirs(searchPaths) {
        const paths = [];
        for (const p of searchPaths) {
            const fullPath = path.resolve(p);
            try {
                const stat = await lstat(fullPath);
                if (stat.isDirectory()) {
                    paths.push(fullPath);
                }
            }
            catch (err) {
                // ...
            }
        }
        const watcher = chokidar.watch(paths);
        watcher.on('all', (event, fullPath) => {
            fullPath = path.resolve(fullPath);
            if (event === 'change' && fullPath in this.pathsToNames) {
                this.emit('update', this.pathsToNames[fullPath]);
            }
        });
        watcher.on('error', (err) => {
            console.error('Watcher error: ' + err);
        });
        this.fsWatcher = watcher;
    }
    async getSourceAsync(name) {
        let res = null;
        for (const p of this.searchPaths) {
            const basePath = path.resolve(p);
            const fullPath = path.resolve(p, name);
            if (fullPath.startsWith(basePath)) {
                try {
                    const stat = await lstat(fullPath);
                    if (stat && stat.isFile()) {
                        const data = await readFile(fullPath, 'utf-8');
                        res = { src: data, path: fullPath, noCache: this.noCache };
                        this.pathsToNames[fullPath] = name;
                        break;
                    }
                }
                catch (err) {
                    // ...
                }
            }
        }
        if (!res) {
            throw new Error(`Not found template "${name}".`);
        }
        return res;
    }
    async destroy() {
        if (this.fsWatcher) {
            await this.fsWatcher.close();
        }
    }
    getSource(name, callback) {
        this.getSourceAsync(name)
            .then((res) => {
            callback(null, res);
        })
            .catch((err) => callback(err, null));
    }
}
export default FileSystemAsyncLoader;
